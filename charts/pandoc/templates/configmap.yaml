apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "pandoc.fullname" . }}-api
  labels:
    {{- include "pandoc.labels" . | nindent 4 }}
data:
  server.py: |
    #!/usr/bin/env python3
    """Simple HTTP API for pandoc document conversion."""
    
    import http.server
    import json
    import subprocess
    import tempfile
    import os
    from urllib.parse import parse_qs, urlparse
    
    class PandocHandler(http.server.BaseHTTPRequestHandler):
        def log_message(self, format, *args):
            print(f"[{self.log_date_time_string()}] {format % args}")
        
        def do_GET(self):
            """Health check and API info."""
            self.send_response(200)
            self.send_header('Content-Type', 'application/json')
            self.end_headers()
            info = {
                "service": "pandoc-api",
                "version": "3.1",
                "endpoints": {
                    "GET /": "This info",
                    "POST /convert": "Convert document (form: from, to, content)",
                    "POST /convert/json": "Convert with JSON body"
                },
                "formats": ["markdown", "html", "pdf", "docx", "latex", "rst", "json"]
            }
            self.wfile.write(json.dumps(info, indent=2).encode())
        
        def do_POST(self):
            """Handle conversion requests."""
            parsed = urlparse(self.path)
            
            if parsed.path == '/convert':
                self.handle_form_convert()
            elif parsed.path == '/convert/json':
                self.handle_json_convert()
            else:
                self.send_error(404, "Unknown endpoint")
        
        def handle_form_convert(self):
            """Handle form-encoded conversion."""
            content_length = int(self.headers.get('Content-Length', 0))
            post_data = self.rfile.read(content_length).decode('utf-8')
            params = parse_qs(post_data)
            
            from_fmt = params.get('from', ['markdown'])[0]
            to_fmt = params.get('to', ['html'])[0]
            content = params.get('content', [''])[0]
            
            self.run_conversion(from_fmt, to_fmt, content)
        
        def handle_json_convert(self):
            """Handle JSON conversion."""
            content_length = int(self.headers.get('Content-Length', 0))
            post_data = self.rfile.read(content_length).decode('utf-8')
            
            try:
                data = json.loads(post_data)
                from_fmt = data.get('from', 'markdown')
                to_fmt = data.get('to', 'html')
                content = data.get('content', '')
                options = data.get('options', [])
                
                self.run_conversion(from_fmt, to_fmt, content, options)
            except json.JSONDecodeError as e:
                self.send_error(400, f"Invalid JSON: {e}")
        
        def run_conversion(self, from_fmt, to_fmt, content, options=None):
            """Execute pandoc conversion."""
            options = options or []
            
            with tempfile.NamedTemporaryFile(mode='w', suffix=f'.{from_fmt}', delete=False) as f:
                f.write(content)
                input_file = f.name
            
            output_file = input_file + f'.{to_fmt}'
            
            try:
                cmd = [
                    'pandoc',
                    input_file,
                    '-f', from_fmt,
                    '-t', to_fmt,
                    '-o', output_file
                ]
                cmd.extend(options)
                
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
                
                if result.returncode != 0:
                    self.send_response(400)
                    self.send_header('Content-Type', 'application/json')
                    self.end_headers()
                    self.wfile.write(json.dumps({
                        "error": "Conversion failed",
                        "stderr": result.stderr
                    }).encode())
                    return
                
                with open(output_file, 'rb') as f:
                    output = f.read()
                
                self.send_response(200)
                
                # Set appropriate content type
                mime_types = {
                    'html': 'text/html',
                    'pdf': 'application/pdf',
                    'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
                    'json': 'application/json'
                }
                content_type = mime_types.get(to_fmt, 'text/plain')
                self.send_header('Content-Type', content_type)
                self.end_headers()
                self.wfile.write(output)
                
            except subprocess.TimeoutExpired:
                self.send_error(504, "Conversion timeout")
            except Exception as e:
                self.send_error(500, str(e))
            finally:
                try:
                    os.unlink(input_file)
                    if os.path.exists(output_file):
                        os.unlink(output_file)
                except:
                    pass
    
    if __name__ == '__main__':
        server = http.server.HTTPServer(('0.0.0.0', 8080), PandocHandler)
        print("Pandoc API server running on port 8080")
        server.serve_forever()
